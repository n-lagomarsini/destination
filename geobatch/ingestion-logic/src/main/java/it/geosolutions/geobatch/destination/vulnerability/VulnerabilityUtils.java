/*
 *  Copyright (C) 2007-2012 GeoSolutions S.A.S.
 *  http://www.geo-solutions.it
 *
 *  GPLv3 + Classpath exception
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package it.geosolutions.geobatch.destination.vulnerability;

import it.geosolutions.destination.utils.BufferUtils;
import it.geosolutions.geobatch.destination.vulnerability.TargetManager.TargetInfo;
import it.geosolutions.jaiext.range.Range;
import it.geosolutions.jaiext.range.RangeFactory;
import it.geosolutions.jaiext.stats.Statistics.StatsType;
import it.geosolutions.jaiext.zonal.ZonalStatsDescriptor;
import it.geosolutions.jaiext.zonal.ZonalStatsRIF;
import it.geosolutions.jaiext.zonal.ZoneGeometry;

import java.awt.Rectangle;
import java.awt.RenderingHints;
import java.awt.geom.Rectangle2D;
import java.awt.image.DataBuffer;
import java.awt.image.RenderedImage;
import java.awt.image.renderable.ParameterBlock;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;

import javax.imageio.ImageIO;
import javax.imageio.stream.ImageInputStream;
import javax.media.jai.JAI;
import javax.media.jai.ParameterBlockJAI;
import javax.media.jai.ROI;
import javax.media.jai.RenderedOp;

import org.geotools.feature.FeatureCollection;
import org.geotools.filter.function.RangedClassifier;
import org.geotools.gce.geotiff.GeoTiffReader;
import org.geotools.geometry.jts.JTS;
import org.geotools.image.jai.Registry;
import org.jaitools.imageutils.ROIGeometry;
import org.jaitools.media.jai.zonalstats.Result;
import org.jaitools.media.jai.zonalstats.ZonalStats;
import org.jaitools.numeric.Statistic;
import org.opengis.feature.simple.SimpleFeature;
import org.opengis.feature.simple.SimpleFeatureType;
import org.opengis.filter.FilterFactory2;
import org.opengis.filter.expression.Function;
import org.opengis.referencing.datum.PixelInCell;
import org.opengis.referencing.operation.MathTransform;
import org.opengis.referencing.operation.NoninvertibleTransformException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.sun.media.jai.operator.ImageReadDescriptor;
import com.vividsolutions.jts.geom.Envelope;
import com.vividsolutions.jts.geom.Geometry;

/**
 * @author DamianoG
 * @author Daniele Romagnoli, GeoSolutions SAS
 * 
 */
public class VulnerabilityUtils {

    public static final RenderingHints NO_TILE_CACHE = new RenderingHints(JAI.KEY_TILE_CACHE, null);
    private final static Logger LOGGER = LoggerFactory.getLogger(VulnerabilityUtils.class);
    
    //static {
        //try {
        	//ImageIO.scanForPlugins();
            //Registry.registerRIF(JAI.getDefaultInstance(), new ZonalStatsDescriptor(),
                    //new ZonalStatsRIF(), Registry.JAI_TOOLS_PRODUCT);

    static {
        try {
            Registry.registerRIF(JAI.getDefaultInstance(), new ZonalStatsDescriptor(),
                    new ZonalStatsRIF(), VulnerabilityComputation.JAI_EXT_PRODUCT);

        } catch (Throwable e) {
            // swallow exception in case the op has already been registered.
        }
    }

    public static Map<Double, Geometry> computeBuffers(SimpleFeature arc, DistancesPair distances) {

        Double[] distanceValues = distances.getRight();
        Geometry geometry = (Geometry) arc.getDefaultGeometry();
        Map<Double, Geometry> bufferMap = new HashMap<Double, Geometry>();
        double previousDistance = 0.0;
        for (int count = 0; count < distanceValues.length; count++) {
            double distanceValue = distanceValues[count];

            geometry = BufferUtils.iterativeBuffer(geometry, distanceValue - previousDistance, 50);
            previousDistance = distanceValue;

            bufferMap.put(distanceValue, geometry);
        }

        return bufferMap;
    }

    /**
     * Convert originGeom into the raster space using the provided w2g
     * 
     * @param originGeom the origin geometry to convert
     * @param gtr
     * @return
     * @throws Exception
     * @throws Exception
     */
    public static Geometry toRasterSpace(Geometry originGeom, MathTransform w2g) throws Exception,
            Exception {

        if (originGeom == null)
            LOGGER.info("--> " + originGeom);
        return JTS.transform(originGeom, w2g);
    }

    public static Double getNoDataValue(GeoTiffReader gtr) {

        if (!gtr.getMetadata().hasNoData()) {
            return null;
        }
        return gtr.getMetadata().getNoData();
    }

    public static RenderedImage cropImage(RenderedImage image, Geometry roi) {

        ParameterBlock pb = new ParameterBlock();
        pb.addSource(image);
        Envelope bbox = roi.getEnvelopeInternal();
        try {
	        Envelope imageBbox = new Envelope(image.getMinX(), image.getWidth(), image.getMinY(), image.getHeight());
	        Envelope finalBBox = imageBbox.intersection(bbox);
	        if(finalBBox == null || finalBBox.isNull()){
	            return null;
	        }
	        setCropParam(pb, finalBBox, image);
	        //Creates the cropped area
	        image = JAI.create("Crop", pb);
        } catch(Throwable t) {
        	t.printStackTrace();
        }
        return image;
    }

    /**
     * Set the crop parameters. Make sure the resulting crop is fully contained within the image bbox. Also do some small refinements in case the
     * rounded values are outside the edges.
     * 
     * @param pb
     * @param finalBBox
     * @param image
     */
    private static void setCropParam(ParameterBlock pb, Envelope finalBBox, RenderedImage image) {
        double finalX = finalBBox.getMinX();
        double finalY = finalBBox.getMinY();
        double finalWidth = finalBBox.getWidth();
        double finalHeight = finalBBox.getHeight();

        // Get the original image properties
        final int imageMinX = image.getMinX();
        final int imageMinY = image.getMinY();
        final int imageMaxX = imageMinX + image.getWidth();
        final int imageMaxY = imageMinY + image.getHeight();

        // Setup the same requested rectangle which is computed by the crop operation
        final Rectangle rect_req = (new Rectangle2D.Float((float) finalX, (float) finalY,
                (float) finalWidth, (float) finalHeight)).getBounds();
        final int requestedMinX = (int) rect_req.getMinX();
        final int requestedMinY = (int) rect_req.getMinY();
        final int requestedMaxX = (int) rect_req.getMaxX();
        final int requestedMaxY = (int) rect_req.getMaxY();

        // Refine the edge to solve some issues on corner cases
        if (requestedMinX < imageMinX) {
            finalX = imageMinX;
        }
        if (requestedMaxX > imageMaxX) {
            finalWidth -= 1;// 0.5;
        }
        if (requestedMinY < imageMinY) {
            finalY = imageMinY;
        }
        if (requestedMaxY > imageMaxY) {
            finalHeight -= 1;// 0.5;
        }

        if (finalWidth <= 0) {
            finalWidth = 1;
        }

        if (finalHeight <= 0) {
            finalHeight = 1;
        }

        // Set the cropping parameters
        pb.add((float) finalX);
        pb.add((float) finalY);
        pb.add((float) finalWidth);
        pb.add((float) finalHeight);
    }

    /**
     * Perform the sum of the pixels of the provided raster inside the ROI and on the selected band.
     * 
     * @param geometries List of Geometry or ROIGeometry objects containing the geometries associated with the
     * @param image input target image
     * @param noData value associated with No Data
     * @param band index associated with the band on which the calculations must be performed
     * @param valuesToCount if NULL the sum is performed on all values not equals to NODATA, otherwise the sum is performed on each group of Integer.
     *        Basically this parameter means that the clients want to count the pixels with certain value using getNumOffered() method of Result class
     * 
     * @return the result as a List of Jai-Ext ZoneGeometry objects
     */
    public static List<ZoneGeometry> sumCellsInsideBuffer(List geometries, RenderedImage image,
            Double noData, int band, Map<Integer, String> valuesToCount) {

        // Creation of an empty list of zones
        List<ROI> roilist = null;

        // First element used for checking if the List contains Geometry objects or ROI objects
        Object element = geometries.get(0);

        // if the List contains Geometry objects
        if (element instanceof Geometry) {
            // Then for each geometry is created an associated ROIGeometry object
            roilist = new ArrayList<ROI>(geometries.size());

            List<Geometry> geometryList = geometries;

            for (Geometry geom : geometryList) {
                if (LOGGER.isDebugEnabled()) {
                    image.getHeight();
                    LOGGER.debug("roiGeom: " + ((geom != null) ? geom.getArea() : "null")
                            + " - image: " + image + " - noData:" + noData + " - band:" + band
                            + " - valuesToCount:" + valuesToCount + " size: "
                            + ((valuesToCount != null) ? valuesToCount.size() : "null"));
                }
                ROI roi = new ROIGeometry(geom);
                roilist.add(roi);
            }
            // if the List contains ROI objects
        } else if (element instanceof ROI) {
            // Then the list is copied
            roilist = geometries;

        } else {
            throw new IllegalArgumentException("The input list is not a ROI or a Geometry List");
        }

        // Statistic Calculation

        // Creation of the parameterBlock associated with the "Zonal" operation
        ParameterBlockJAI pb = new ParameterBlockJAI("Zonal");

        // Setting of the source image
        pb.setSource(image, 0);
        // Setting of the zones
        pb.setParameter("roilist", roilist);

        // Selection of the statistic to compute
        StatsType[] stats = { StatsType.SUM };

        // Setting of the parameters associated with the statistics and the bands
        pb.setParameter("stats", stats);
        pb.setParameter("bands", new int[] { band });

        // Setting of the optional Ranges on which the calculations are performed
        if (valuesToCount != null && !valuesToCount.isEmpty()) {
            List<Range> ranges = new ArrayList<Range>();
            for (Integer el : valuesToCount.keySet()) {
                int value = el.intValue();
                ranges.add(RangeFactory.create(value, true, value, true));
            }
            pb.setParameter("rangeData", ranges);
            pb.setParameter("localStats", true);
        }

        // If No Data are present, they are passed to the parameterBlock as a Range object
        if (noData != null) {
            // Image data type
            int dataType = image.getSampleModel().getDataType();

            Range rangeNoData;
            // Selection of the range associated to the image data type
            switch (dataType) {
            case DataBuffer.TYPE_BYTE:
                rangeNoData = RangeFactory.create(noData.byteValue(), true, noData.byteValue(),
                        true);
                break;
            case DataBuffer.TYPE_USHORT:
                rangeNoData = RangeFactory.createU(noData.shortValue(), true, noData.shortValue(),
                        true);
                break;
            case DataBuffer.TYPE_SHORT:
                rangeNoData = RangeFactory.create(noData.shortValue(), true, noData.shortValue(),
                        true);
                break;
            case DataBuffer.TYPE_INT:
                rangeNoData = RangeFactory.create(noData.intValue(), true, noData.intValue(), true);
                break;
            case DataBuffer.TYPE_FLOAT:
                rangeNoData = RangeFactory.create(noData.floatValue(), true, noData.floatValue(),
                        true, true);
                break;
            case DataBuffer.TYPE_DOUBLE:
                rangeNoData = RangeFactory.create(noData.doubleValue(), true, noData.doubleValue(),
                        true, true);
                break;
            default:
                throw new IllegalArgumentException("Wrong Image data type");
            }
            // Setting of the noData parameter
            pb.setParameter("noData", rangeNoData);
        }

        // Creation of the RenderedOp associated with the Zonal operation
        RenderedOp op = JAI.create("Zonal", pb,VulnerabilityUtils.NO_TILE_CACHE);

        // Statistics per zone
        List<ZoneGeometry> results = (List<ZoneGeometry>) op
                .getProperty(ZonalStatsDescriptor.ZS_PROPERTY);

        return results;
    }

    /**
     * Perform the sum of the pixels of the provided raster inside the ROI and on the selected band.
     * 
     * @param geometries List of ROIGeometry objects containing the geometries associated with the
     * @param image input target image
     * @param noData value associated with No Data
     * @param targets Map on which each Target is associated to a band value
     * 
     * @return the result as a List of Jai-Ext ZoneGeometry objects
     */
    public static List<ZoneGeometry> sumCellsInsideBuffer(List<ROI> roilist, RenderedImage image,
            Double noData, Map<Integer, TargetInfo> targets) {

        // Statistic Calculation

        // Creation of the parameterBlock associated with the "Zonal" operation
        ParameterBlockJAI pb = new ParameterBlockJAI("Zonal");

        // Setting of the source image
        pb.setSource(image, 0);
        // Setting of the zones
        pb.setParameter("roilist", roilist);

        // Selection of the statistic to compute
        StatsType[] stats = { StatsType.SUM };

        // Setting of the parameters associated with the statistics and the bands
        pb.setParameter("stats", stats);

        // Setting of the bands on which the calculations must be done
        Set<Integer> bandSet = targets.keySet();
        // initialization of the band array
        int[] bands = new int[bandSet.size()];
        // Array index for each band
        int bandIndex = 0;
        // Cycle on all the bands
        for (int band : bandSet) {
            // Array update
            bands[bandIndex] = band;
            // Index Update
            bandIndex++;
        }

        // Setting of the band parameter
        pb.setParameter("bands", bands);

        // // Setting of the optional Ranges on which the calculations are performed
        // if (valuesToCount != null && !valuesToCount.isEmpty()) {
        // List<Range> ranges = new ArrayList<Range>();
        // for (Integer el : valuesToCount.keySet()) {
        // int value = el.intValue();
        // ranges.add(RangeFactory.create(value, true, value, true));
        // }
        // pb.setParameter("rangeData", ranges);
        // pb.setParameter("localStats", true);
        // }

        // If No Data are present, they are passed to the parameterBlock as a Range object
        if (noData != null) {
            // Image data type
            int dataType = image.getSampleModel().getDataType();

            Range rangeNoData;
            // Selection of the range associated to the image data type
            switch (dataType) {
            case DataBuffer.TYPE_BYTE:
                rangeNoData = RangeFactory.create(noData.byteValue(), true, noData.byteValue(),
                        true);
                break;
            case DataBuffer.TYPE_USHORT:
                rangeNoData = RangeFactory.createU(noData.shortValue(), true, noData.shortValue(),
                        true);
                break;
            case DataBuffer.TYPE_SHORT:
                rangeNoData = RangeFactory.create(noData.shortValue(), true, noData.shortValue(),
                        true);
                break;
            case DataBuffer.TYPE_INT:
                rangeNoData = RangeFactory.create(noData.intValue(), true, noData.intValue(), true);
                break;
            case DataBuffer.TYPE_FLOAT:
                rangeNoData = RangeFactory.create(noData.floatValue(), true, noData.floatValue(),
                        true, true);
                break;
            case DataBuffer.TYPE_DOUBLE:
                rangeNoData = RangeFactory.create(noData.doubleValue(), true, noData.doubleValue(),
                        true, true);
                break;
            default:
                throw new IllegalArgumentException("Wrong Image data type");
            }
            // Setting of the noData parameter
             pb.setParameter("noData", rangeNoData);
        }

        // Creation of the RenderedOp associated with the Zonal operation
        RenderedOp op = JAI.create("Zonal", pb,VulnerabilityUtils.NO_TILE_CACHE);

        // Statistics per zone
        List<ZoneGeometry> results = (List<ZoneGeometry>) op
                .getProperty(ZonalStatsDescriptor.ZS_PROPERTY);
        op.dispose();

        return results;
    }

    
    
    /**
     * Perform the sum of the pixels of the provided raster inside the ROI and on the selected band.
     * @param roiGeom
     * @param image
     * @param noData
     * @param band
     * @param valuesToCount if NULL the sum is performed on all values not equals to NODATA, otherwise the sum is performed on each group of Integer.
     *                          Basically this parameter means that the clients want to count the pixels with certain value using getNumOffered() method of Result class  
     * 
     * @return the result as JaiTools Result object
     */
        public static List<Result> sumCellsInsideBuffer(Geometry roiGeom,
                        RenderedImage image, Double noData, int band,
                        Map<Integer, String> valuesToCount) {
        
        if(LOGGER.isDebugEnabled()){
            image.getHeight();
            LOGGER.debug("roiGeom: " + ((roiGeom!=null)?roiGeom.getArea():"null") +
                            " - image: " + image + 
                            " - noData:" + noData +
                            " - band:" + band +
                            " - valuesToCount:" + valuesToCount + " size: " + ((valuesToCount!=null)?valuesToCount.size():"null") 
                            );
        }
        ROI roi = new ROIGeometry(roiGeom);
        ParameterBlockJAI pb = new ParameterBlockJAI("ZonalStats");
        pb.setSource("dataImage", image);
        // pb.setSource("zoneImage", myZones);
        pb.setParameter("roi", roi);

        Statistic[] stats = { Statistic.SUM, };

        pb.setParameter("stats", stats);
        pb.setParameter("bands", new Integer[] { band });
        
        if(valuesToCount!= null && !valuesToCount.isEmpty()){
            List<org.jaitools.numeric.Range> ranges = new ArrayList<org.jaitools.numeric.Range>();
            for(Integer el : valuesToCount.keySet()){
                ranges.add(new org.jaitools.numeric.Range(el, true, el, true));
            }
            pb.setParameter("ranges", ranges);
            pb.setParameter("rangesType",org.jaitools.numeric.Range.Type.INCLUDE);
            pb.setParameter("rangeLocalStats",Boolean.TRUE);
        }
        
        List<org.jaitools.numeric.Range> dataNDR = null;
        if (noData != null) {
            org.jaitools.numeric.Range nodata = new org.jaitools.numeric.Range(noData, true, noData, true);
            dataNDR = new ArrayList<org.jaitools.numeric.Range>();
            dataNDR.add(nodata);
            pb.setParameter("noDataRanges", dataNDR);
        }
        
        RenderedOp op = JAI.create("ZonalStats", pb);

        ZonalStats res = (ZonalStats) op.getProperty(org.jaitools.media.jai.zonalstats.ZonalStatsDescriptor.ZONAL_STATS_PROPERTY);

        return res.results();
    }
    
    /**
     * Loads a {@link RenderedImage} from the specified file with the specified mode.
     * 
     * @param mode, {@link ComputationMode} can be {@link ComputationMode#DEFERRED} or {@link ComputationMode#IMMEDIATE} as per the JAI meaning.
     * @param tiffFile the input {@link File} where to read from.
     * 
     * @return
     * @throws IOException in case the creation of the {@link ImageInputStream} or the Immediate read with Imageio fails.
     */
    public static RenderedImage loadImage(boolean deferred, File tiffFile) throws IOException {
        return loadImage(deferred, tiffFile, false);
    }
    
    public static RenderedImage loadImage(boolean deferred, File tiffFile,boolean cache) throws IOException {
        // checks
        if (!tiffFile.isFile() || !tiffFile.exists() || !tiffFile.canRead()) {
            throw new IllegalArgumentException("Unable to load image from file: "
                    + tiffFile.getAbsolutePath() + "\n" + "isFile=" + tiffFile.isFile() + "\n"
                    + "exists=" + tiffFile.exists() + "\n" + "canRead=" + tiffFile.canRead());
        }

        if (deferred) {
            final ImageInputStream inStream = ImageIO.createImageInputStream(tiffFile);
            if (inStream == null) {
                throw new IllegalArgumentException("Unable to create input stream from file: "
                        + tiffFile.getAbsolutePath() + "\n" + "isFile=" + tiffFile.isFile() + "\n"
                        + "exists=" + tiffFile.exists() + "\n" + "canRead=" + tiffFile.canRead());
            }
            if(cache){
                return ImageReadDescriptor.create(inStream, Integer.valueOf(0), false, false, false,
                        null, null, null, null, null);
            }
            return ImageReadDescriptor.create(inStream, Integer.valueOf(0), false, false, false,
                    null, null, null, null, NO_TILE_CACHE);// NO CACHING
                    
        } else {
            return ImageIO.read(tiffFile);
        }
    }

    /**
     * Setup {@link TargetInfo} objects on top of the specified targetURIs
     * 
     * @param targetURIs
     * @return
     * @throws IOException
     * @throws NoninvertibleTransformException
     */
    public static Map<String, TargetInfo> loadTargets(String basePath, Map vulnerabilityCfg,
            int pixelArea) throws IOException {
        Map<String, TargetInfo> targetInfo = new HashMap<String, TargetInfo>();

        Iterator iter = vulnerabilityCfg.keySet().iterator();
        while (iter.hasNext()) {
            int key = (Integer) iter.next();
            Map targetCfg = (Map) vulnerabilityCfg.get(key);
            if (targetCfg.containsKey("FILENAME") && !targetCfg.containsKey("ISGROUP")) {
                String imgPath = (String) targetCfg.get("FILENAME");
                TargetType type = targetCfg.containsKey("HUMANS")
                        && (Boolean) targetCfg.get("HUMANS") ? TargetType.COMPUTEPIXEL
                        : TargetType.COMPUTEAREA;
                File inputImage = new File(basePath + File.separator + imgPath);
                if (!inputImage.exists()) {
                    if (targetCfg.containsKey("GROUP")) {
                        int group = (Integer) targetCfg.get("GROUP");
                        Map groupCfg = (Map) vulnerabilityCfg.get(group);
                        if (groupCfg != null) {
                            imgPath = (String) groupCfg.get("FILENAME");
                            inputImage = new File(basePath + File.separator + imgPath);
                            if (inputImage.exists()) {
                                type = TargetType.GROUPED;
                            }
                        }
                    }
                }
                if (inputImage.exists()) {
                    RenderedImage image = VulnerabilityUtils.loadImage(true, inputImage);
                    GeoTiffReader gtr = null;
                    try {
                        gtr = new GeoTiffReader(inputImage);
                        MathTransform w2g = getWorld2Grid(gtr);
                        Double noData = getNoDataValue(gtr);
                        TargetInfo info = new TargetInfo("" + key, w2g, noData, image, type,
                                vulnerabilityCfg, pixelArea);
                        boolean hasBeenMerged = false;
                        for (String existingKey : targetInfo.keySet()) {
                            TargetInfo merged = targetInfo.get(existingKey).mergeWith(info);
                            if (merged != null) {
                                hasBeenMerged = true;
                            }

                        }
                        if (!hasBeenMerged) {
                            targetInfo.put("" + key, info);
                        }

                    } finally {
                        if (gtr != null) {
                            try {
                                gtr.dispose();
                            } catch (Throwable t) {

                            }
                        }
                    }
                } else {
                    // check for group

                }
            }
        }
        return targetInfo;
    }

    public static Map<String, Double[]> loadDistances(Map vulnerabilityCfg) {

        Map<String, Double[]> map = new HashMap<String, Double[]>();

        Iterator iter = vulnerabilityCfg.keySet().iterator();
        while (iter.hasNext()) {
            int key = (Integer) iter.next();
            Map cfg = (Map) vulnerabilityCfg.get(key);
            if (cfg.containsKey("DISTANCES")) {
                String el = (String) cfg.get("DISTANCES");
                Double[] distances = createDistancesArray(el);
                map.put("" + key, distances);
            }

        }
        return map;
    }

    public static Double[] createDistancesArray(String csvDistances) {

        String[] distances = csvDistances.split(";");
        Double[] distancesInt = new Double[distances.length];
        for (int j = 0; j < distancesInt.length; j++) {
            distancesInt[j] = Double.parseDouble(distances[j]);
        }
        return distancesInt;
    }

    public static MathTransform getWorld2Grid(GeoTiffReader gtr) throws IOException {
        // get the world to grid matrix
        MathTransform g2w = gtr.getOriginalGridToWorld(PixelInCell.CELL_CORNER);
        try {
            return g2w.inverse();
        } catch (NoninvertibleTransformException e) {
            throw new IOException("exception occurred while computing target transformation",
                    e.getCause());
        }
    }

    public static Map<String, GeoTiffReader> loadGTIFFReaders(Properties targetURIs)
            throws IOException {
        Map<String, GeoTiffReader> targetReaders = new HashMap<String, GeoTiffReader>();
        Iterator iter = targetURIs.keySet().iterator();
        while (iter.hasNext()) {
            String el2 = (String) iter.next();
            String imgAbsolutePath = targetURIs.getProperty(el2);
            GeoTiffReader gtr = new GeoTiffReader(new File(imgAbsolutePath));
            targetReaders.put(el2, gtr);
        }
        return targetReaders;
    }

    public static void disposeGTIFFReaders(Map<String, GeoTiffReader> readersMap)
            throws IOException {
        for (String el : readersMap.keySet()) {
            GeoTiffReader gtr = readersMap.get(el);
            if (gtr != null) {
                gtr.dispose();
            }
        }
    }

    /**
     * @param i
     * @return
     */
    public static List<Integer> loadGroupValues(int group, Map vulnerabilityCfg) {
        List<Integer> result = new ArrayList<Integer>();

        Iterator iter = vulnerabilityCfg.keySet().iterator();
        while (iter.hasNext()) {
            int key = (Integer) iter.next();
            Map cfg = (Map) vulnerabilityCfg.get(key);
            if (cfg.containsKey("GROUP") && cfg.containsKey("GROUPVALUE")) {
                int groupId = (Integer) cfg.get("GROUP");
                if (groupId == group) {
                    int groupValue = (Integer) cfg.get("GROUPVALUE");
                    result.add(groupValue);
                }
            }

        }
        return result;
    }
    
    public static RangedClassifier computeIntervals(VulnerabilityComputation vulnerability,
            int threadMaxNumber, String cellStart, boolean skipArcs) throws IOException {
        FeatureCollection<SimpleFeatureType, SimpleFeature> cells = vulnerability.geometryIDList(cellStart, skipArcs);

        FilterFactory2 filterFactory = VulnerabilityOperation.filterFactory;

        Function classify = filterFactory.function("EqualInterval",
                filterFactory.property("id_geo_arco"), filterFactory.literal(threadMaxNumber));

        RangedClassifier groups = (RangedClassifier) classify.evaluate(cells);

        return groups;
    }
}
