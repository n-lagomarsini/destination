/*
 *  Copyright (C) 2007-2012 GeoSolutions S.A.S.
 *  http://www.geo-solutions.it
 *
 *  GPLv3 + Classpath exception
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package it.geosolutions.geobatch.destination.vulnerability;

import static it.geosolutions.geobatch.destination.vulnerability.VulnerabilityComputation.GEOID;
import static it.geosolutions.geobatch.destination.vulnerability.VulnerabilityComputation.PARTNER_FIELD;
import it.geosolutions.geobatch.destination.common.OutputObject;
import java.io.IOException;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import org.geotools.data.DataUtilities;
import org.geotools.data.DefaultTransaction;
import org.geotools.data.Query;
import org.geotools.data.Transaction;
import org.geotools.factory.CommonFactoryFinder;
import org.geotools.factory.Hints;
import org.geotools.feature.NameImpl;
import org.geotools.feature.simple.SimpleFeatureBuilder;
import org.opengis.feature.simple.SimpleFeature;
import org.opengis.feature.type.AttributeDescriptor;
import org.opengis.feature.type.Name;
import org.opengis.filter.Filter;
import org.opengis.filter.FilterFactory2;
import org.opengis.geometry.BoundingBox;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * @author DamianoG
 * 
 *         This class is responsible for:
 *         <ul>
 *         <li>Build the appropriate filter for the arcs source</li>
 *         <li>Persist the results of vulnerability process into a geotools Store</li>
 *         </ul>
 * 
 *         handling three modality, called <b>Operations</b> and implemented as inner classes:
 * 
 *         <ul>
 *         <li><b>UPDATE</b>: Add new records for distance not computed and update old record for target not computed. Never delete existing records</li>
 *         <li><b>INSERT</b>: Filter existing data [arcID,distance] and compute the rest of the arcs</li>
 *         <li><b>PURGE_INSERT</b>: Removes all existing data before start the computation.</li>
 *         </ul>
 * 
 *         <b>NOTE</b> that each operation has the possibility of reducing the set of arcs to compute through a pagining-like system that it is
 *         configurable in the scripting action input event.
 * 
 *         This abstarct class can be instantiate through the instantiateWriter() method that given a write mode instantiate the right implementation
 *         for using it in Update or Insert.
 * 
 *         TODO generalize it and use also in other processes.
 * 
 */
public abstract class VulnerabilityOperation {

    private final static Logger LOGGER = LoggerFactory.getLogger(VulnerabilityOperation.class);

    private final static boolean NO_DBWRITES_FOR_TESTS;

    static {
        String noWrites = System.getProperty("it.geosolutions.vulnerability.nowritesondb");
        if (noWrites != null && noWrites.equalsIgnoreCase("TRUE")) {
            NO_DBWRITES_FOR_TESTS = true;
        } else {
            NO_DBWRITES_FOR_TESTS = false;
        }
    }

    public static Double DISTANCE_NOT_SET_VALUE = 0d;

    public static String DISTANCE_ID = "id_distanza";

    public static FilterFactory2 filterFactory = CommonFactoryFinder.getFilterFactory2();

    /**
     * The record to start with (Used for Filtering)
     */
    protected Long startOriginId;

    /**
     * The record to start with (Used for Filtering)
     */
    protected Long endOriginId;

    /**
     * Num of pages (Used for Filtering)
     */
    protected Long totPages;

    /**
     * PageNumber (Used for Filtering)
     */
    protected Long pageNumber;

    public enum OperationType {
        INSERT, UPDATE, PURGE_INSERT
    };

    /**
     * return a VulnerabilityResultsWriter suitable for the provided mode. By default return the more conservative mode, WriterUpdate don't remove the
     * records for a given partner.
     * 
     * @param mode
     * @return
     */
    public static VulnerabilityOperation instantiateWriter(OperationType mode) {
        if (mode == null) {
            return new UpdateOperation();
        }
        switch (mode) {
        case PURGE_INSERT:
            return new PurgeInsertOperation();
        case INSERT:
            return new InsertOperation();
        case UPDATE:
            return new UpdateOperation();
        default:
            return new InsertOperation();
        }
    }

    public static VulnerabilityOperation instantiateWriterFromString(String mode) {
        if (mode == null) {
            return instantiateWriter(null);
        }
        return instantiateWriter(VulnerabilityOperation.OperationType.valueOf(mode));
    }

    protected void addNewVulnerabilityFeature(OutputObject vulnerabilityObject, String id,
            Map<String, Double> map, int partner_id) throws IOException {

        SimpleFeatureBuilder featureBuilder = new SimpleFeatureBuilder(vulnerabilityObject.getBuilder().getFeatureType());
        String[] p_key = id.split("\\.");
        for (AttributeDescriptor attr : vulnerabilityObject.getSchema().getAttributeDescriptors()) {
            if (attr.getLocalName().equals("id_geo_arco")) {
                if (map.get("id_geo_arco") != null)
                    featureBuilder.add(map.get("id_geo_arco"));
                else if (p_key != null && p_key.length > 0)
                    featureBuilder.add(p_key[0]);
            } else if (attr.getLocalName().equals("id_distanza")) {
                if (map.get("id_distanza") != null)
                    featureBuilder.add(map.get("id_distanza"));
                else if (p_key != null && p_key.length > 1)
                    featureBuilder.add(p_key[1]);
            } else if (attr.getLocalName().equals("id_scenario")) {
                if (map.get("id_scenario") != null)
                    featureBuilder.add(map.get("id_scenario"));
            } else if (attr.getLocalName().equals("id_sostanza")) {
                if (map.get("id_sostanza") != null)
                    featureBuilder.add(map.get("id_sostanza"));
            } else if (attr.getLocalName().equals("flg_lieve")) {
                if (map.get("flg_lieve") != null)
                    featureBuilder.add(map.get("flg_lieve"));
            } else if (attr.getLocalName().equals(PARTNER_FIELD)) {
                featureBuilder.add(String.valueOf(partner_id));
            } else {
                Object value = map.get(attr.getLocalName());
                if (value != null) {
                    featureBuilder.add(value);
                } else {
                    if (attr.getType().getBinding() == Double.class
                            || attr.getType().getBinding() == BigDecimal.class)
                        featureBuilder.add(DISTANCE_NOT_SET_VALUE);
                    else
                        featureBuilder.add(null);
                }

            }
        }
        SimpleFeature feature = featureBuilder.buildFeature(id);
        feature.getUserData().put(Hints.USE_PROVIDED_FID, true);
        if (!NO_DBWRITES_FOR_TESTS) {
            vulnerabilityObject.getWriter().addFeatures(DataUtilities.collection(feature));
        }
        featureBuilder.reset();
    }

    public void writeOutputObjects(int trace, OutputObject outputObject, int total,
            String outputName, SimpleFeature inputFeature, String id, Map<String, Double> map,
            int partnerId) throws IOException {

        Transaction rowTransaction = new DefaultTransaction();
        outputObject.getWriter().setTransaction(rowTransaction);

        try {
            addVulnerabilityFeature(outputObject, id, map, partnerId);
            if (!NO_DBWRITES_FOR_TESTS) {
                rowTransaction.commit();
            }
            // updateImportProgress(total, "Importing data in " + outputName);
        } catch (Exception e) {
            rowTransaction.rollback();
            throw new IOException(e);
        } finally {
            rowTransaction.close();
        }

    }

    
    /**
     * Build a filter for iterate over the source table
     * 
     * @param idPartner
     * @param allFeaturesNumber
     * @param bbox
     * @return
     */
    public Filter buildOriginFilterExtended(int idPartner, Integer allFeaturesNumber, BoundingBox bbox, BoundingBox bbox2, String idStart) {

        Filter filter = buildOriginFilter(idPartner, allFeaturesNumber);
        
        // If a bounding box is present, then it is added to the filter
        if (bbox != null && !bbox.isEmpty()) {
            filter = filterFactory.and(filter,
                    filterFactory.bbox(filterFactory.property("geometria"), bbox));
        }
        
        // If a bounding box is present, then it is added to the filter
        if (bbox2 != null && !bbox2.isEmpty()) {
            filter = filterFactory.and(filter,
                    filterFactory.bbox(filterFactory.property("geometria"), bbox2));
        }
        
        if(idStart!=null){
            filter = filterFactory.and(filter, filterFactory.greaterOrEqual(filterFactory.property(GEOID),filterFactory.literal(idStart)));
        }
        
        return filter;
    }
    
    
    
    /**
     * Build a filter for iterate over the source table
     * 
     * @param idPartner
     * @param allFeaturesNumber
     * @param bbox
     * @return
     */
    public Filter buildOriginFilter(int idPartner, Integer allFeaturesNumber) {
        Long recordPerPages = null;
        // Definition of the pagination parameters if present
        if (totPages != null && pageNumber != null && allFeaturesNumber != null) {
            recordPerPages = allFeaturesNumber / totPages;
            this.startOriginId = ((pageNumber - 1) * recordPerPages) + 1;
            this.endOriginId = (pageNumber == totPages) ? allFeaturesNumber : startOriginId
                    + recordPerPages;
        }
        // If pagination parameters are set, the filter is bounded by an origin and end Id
        if (this.startOriginId != null && this.endOriginId != null) {
            LOGGER.info("startOriginId: '" + startOriginId + "' - endOriginId: '" + endOriginId
                    + "' - recordPerPages: '" + recordPerPages + "' - totPages: '" + totPages
                    + "' - pageNumber: '" + pageNumber + "'");

            Filter filter = filterFactory.and(
                    filterFactory.equals(filterFactory.property(PARTNER_FIELD),
                            filterFactory.literal(idPartner)),
                    filterFactory.between(filterFactory.property(GEOID),
                            filterFactory.literal(this.startOriginId),
                            filterFactory.literal(this.endOriginId)));
            
            return filter;
        }
        
        // Simple filter on the partner
        Filter filter = filterFactory.equals(filterFactory.property(PARTNER_FIELD),
                filterFactory.literal(idPartner));
        
        return filter;
    }

    
    
    /**
     * Add a new feature (or update an existing one)
     * 
     * @param vulnerabilityObject
     * @param id
     * @param map
     * @param partner_id
     * @throws IOException
     */
    protected abstract void addVulnerabilityFeature(OutputObject vulnerabilityObject, String id,
            Map<String, Double> map, int partner_id) throws IOException;

    /**
     * This method is responsible for initialize the table where the vulnerability process resilts will be stored
     * 
     * @param vulnerabilityObject
     * @param partner_id
     * @throws IOException
     */
    protected abstract void initFeature(OutputObject vulnerabilityObject, int partner_id)
            throws IOException;

    //
    // Accessor method
    //

    /**
     * @param startOriginId the startOriginId to set
     */
    public void setStartOriginId(Long startOriginId) {
        this.startOriginId = startOriginId;
    }

    /**
     * @param endOriginId the endOriginId to set
     */
    public void setEndOriginId(Long endOriginId) {
        this.endOriginId = endOriginId;
    }

    /**
     * @param totPages the totPages to set
     */
    public void setTotPages(Long totPages) {
        this.totPages = totPages;
    }

    /**
     * @param pageNumber the pageNumber to set
     */
    public void setPageNumber(Long pageNumber) {
        this.pageNumber = pageNumber;
    }

    //
    // CONCRETE CLASSES
    //

    /**
     * Removes all existing data before start the computation. if a subset of arcs is specified, remove just that arcs
     * 
     * @author DamianoG
     * 
     */
    public static class PurgeInsertOperation extends InsertOperation {

        @Override
        protected void initFeature(OutputObject vulnerabilityObject, int partnerId)
                throws IOException {
            if (LOGGER.isDebugEnabled()) {
                LOGGER.debug("PurgeInsert Mode: initFeature");
            }
            // Setup the OutputObject (in the case the vulnerability table) remove old values for the partner and detect the max id
            Transaction transaction = new DefaultTransaction();
            try {
                // remove previous data for the given partner and for specified arc range (if it is not null)
                Filter removeFilter = filterFactory.equals(filterFactory.property(PARTNER_FIELD),
                        filterFactory.literal(partnerId));
                if (this.startOriginId != null && this.endOriginId != null) {
                    removeFilter = filterFactory.and(
                            removeFilter,
                            filterFactory.between(filterFactory.property(GEOID),
                                    filterFactory.literal(this.startOriginId),
                                    filterFactory.literal(this.endOriginId)));
                }
                vulnerabilityObject.getWriter().setTransaction(transaction);
                if (!NO_DBWRITES_FOR_TESTS) {
                    vulnerabilityObject.getSource().removeFeatures(removeFilter);
                    transaction.commit();
                }
            } catch (IOException e) {
                LOGGER.error("Error while trying to delete vulnerability objects for partner "
                        + partnerId, e);
                transaction.rollback();
                throw e;
            } finally {
                transaction.close();
            }
        }
    }

    /**
     * Compute the rest of the arcs without remove the old values
     * 
     * TODO Filter existing data [arcID,distance]
     * 
     * @author DamianoG
     * 
     */
    public static class InsertOperation extends VulnerabilityOperation {

        @Override
        protected void addVulnerabilityFeature(OutputObject vulnerabilityObject, String id,
                Map<String, Double> map, int partnerId) throws IOException {

            if (LOGGER.isDebugEnabled()) {
                LOGGER.debug("Insert Mode: addFeature...");
            }
            addNewVulnerabilityFeature(vulnerabilityObject, id, map, partnerId);
        }

        @Override
        protected void initFeature(OutputObject vulnerabilityObject, int partnerId)
                throws IOException {
            if (LOGGER.isDebugEnabled()) {
                LOGGER.debug("Insert Mode: initFeature... nothing to do...");
            }
            // Setup the OutputObject (in the case the vulnerability table) remove old values for the partner and detect the max id
            // Transaction transaction = new DefaultTransaction();
            // try {
            // // remove previous data for the given partner
            // // Filter removeFilter = filterFactory.
            //
            // transaction.commit();
            // } catch (IOException e) {
            // LOGGER.error("Error while trying to delete vulnerability objects for partner " + partnerId, e);
            // transaction.rollback();
            // throw e;
            // } finally {
            // transaction.close();
            // }
        }
    }

    /**
     * Add new records for distance not computed and update old record for target not computed. Never delete existing records
     * 
     * @author DamianoG
     * 
     */
    public static class UpdateOperation extends VulnerabilityOperation {

        @Override
        protected void addVulnerabilityFeature(OutputObject vulnerabilityObject, String id,
                Map<String, Double> map, int partnerId) throws IOException {

            SimpleFeatureBuilder featureBuilder = vulnerabilityObject.getBuilder();
            // get the PK (id_geoarco, distance) from FID
            String[] p_key = id.split("\\.");

            if (LOGGER.isDebugEnabled()) {
                LOGGER.debug("Update Mode: addFeature ID: " + p_key[0] + " - " + p_key[1]);
            }

            // setup the filter for find if a record is already present or not
            Filter updateFilter = filterFactory.and(
                    filterFactory.equals(filterFactory.property(PARTNER_FIELD),
                            filterFactory.literal(partnerId)),
                    filterFactory.and(
                            filterFactory.equals(filterFactory.property(GEOID),
                                    filterFactory.literal(p_key[0])),
                            filterFactory.equals(filterFactory.property(DISTANCE_ID),
                                    filterFactory.literal(p_key[1]))

                    ));

            List<Name> attributeNamesList = new ArrayList<Name>();
            List<Object> attributeValueList = new ArrayList<Object>();

            Iterator iter = map.keySet().iterator();
            while (iter.hasNext()) {
                String key = (String) iter.next();
                attributeNamesList.add(new NameImpl(key));
                attributeValueList.add(map.get(key));
            }

            // If the feature p_key is not present means that a new distance is added so insert a new row
            if (vulnerabilityObject.getReader().getCount(
                    new Query(vulnerabilityObject.getName(), updateFilter)) <= 0) {
                if (LOGGER.isDebugEnabled()) {
                    LOGGER.debug("feature[" + p_key[0] + " - " + p_key[1]
                            + "] is not present... going to insert it");
                }
                addNewVulnerabilityFeature(vulnerabilityObject, id, map, partnerId);
            }
            // Otherwise just a new target is added so update an existing record
            else {
                if (LOGGER.isDebugEnabled()) {
                    LOGGER.debug("feature[" + p_key[0] + " - " + p_key[1]
                            + "] is already present... going to update it");
                }
                vulnerabilityObject.getWriter().modifyFeatures(
                        attributeNamesList.toArray(new NameImpl[attributeNamesList.size()]),
                        attributeValueList.toArray(), updateFilter);
            }

        }

        @Override
        protected void initFeature(OutputObject vulnerabilityObject, int partner_id)
                throws IOException {
            if (LOGGER.isDebugEnabled()) {
                LOGGER.debug("Update Mode: initFeature... nothing to do...");
            }
        }
    }
}
