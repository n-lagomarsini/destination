/*
 *  GeoBatch - Open Source geospatial batch processing system
 *  http://geobatch.geo-solutions.it/
 *  Copyright (C) 2013 GeoSolutions S.A.S.
 *  http://www.geo-solutions.it
 *
 *  GPLv3 + Classpath exception
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package it.geosolutions.geobatch.destination.vulnerability;

import it.geosolutions.geobatch.destination.ingestion.MetadataIngestionHandler;
import it.geosolutions.geobatch.destination.vulnerability.TargetManager.TargetInfo;
import it.geosolutions.geobatch.flow.event.ProgressListenerForwarder;

import java.awt.image.RenderedImage;
import java.io.IOException;
import java.math.BigDecimal;
import java.util.Map;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentSkipListSet;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

import org.geotools.filter.function.RangedClassifier;
import org.geotools.geometry.Envelope2D;
import org.geotools.jdbc.JDBCDataStore;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Utility class used for launching parallel vulnerability computations
 * 
 */
public class VulnerabilityEnvironment {

	/** Maximum queue dimension */
	private static final int MAXIMUM_QUEUE_SIZE = 1000000;

	/** Logger object */
	private final static Logger LOGGER = LoggerFactory
			.getLogger(VulnerabilityEnvironment.class);

	/** Waiting time until each idle thread is destroyed */
	private static final long TIMEOUT = 60;

	/** Latch used for handling the input threads */
	private CountDownLatch latch;

	/** ListenerForwarder passed in input */
	private ProgressListenerForwarder listenerForwarder;

	public VulnerabilityEnvironment(ProgressListenerForwarder listenerForwarder) {
		this.listenerForwarder = listenerForwarder;
	}

	/**
	 * This method calculated the vulnerability on for the levels 1 and 2.
	 * 
	 * The images are divided into Nx*Ny blocks and, for each block,
	 * vulnerability is calculated inside a thread.
	 * 
	 * @param closePhase
	 * @param numXBlocks
	 * @param numYBlocks
	 * @param inputFeature
	 * @param dataStore
	 * @param metadataHandler
	 * @param images
	 * @param bandPerTargetNH
	 * @param bandPerTargetH
	 * @param writeMode
	 * @param aggregationLevel
	 * @param skipArcs
	 * @param xStart
	 * @param yStart
	 * @param idStart
	 * @throws Exception
	 */
	public void computeLevel12(String closePhase, int numXBlocks,
			int numYBlocks, String inputFeature, JDBCDataStore dataStore,
			MetadataIngestionHandler metadataHandler, RenderedImage[] images,
			Map<Integer, TargetInfo> bandPerTargetNH,
			Map<Integer, TargetInfo> bandPerTargetH, String writeMode,
			int aggregationLevel, boolean skipArcs, Integer[] xStartArray,
			Integer[] yStartArray, Integer[] xStopArray, Integer[] yStopArray,
			String idStart, Envelope2D bbox) throws Exception {

		// Block division variables
		int minTileX = images[1].getMinTileX();
		int minTileY = images[1].getMinTileY();

		int maxTileX = minTileX + images[1].getNumXTiles();
		int maxTileY = minTileY + images[1].getNumYTiles();

		int calcWidth = images[1].getNumXTiles()/ numXBlocks + 1;
		int calcHeight = images[1].getNumYTiles() / numXBlocks + 1;

		 Integer[] xStartAr = null;
         Integer[] yStartAr = null;
         Integer[] xStopAr = null;
         Integer[] yStopAr = null;
		
//        Integer[] xStartAr = new Integer[]{0,0,minTileX + calcWidth +1,minTileX + calcWidth +1};
//        Integer[] yStartAr = new Integer[]{minTileY + calcHeight -1,  minTileY + calcHeight -1 , minTileY + calcHeight-1, minTileY + calcHeight-1};
//        Integer[] xStopAr = new Integer[]{minTileX + calcWidth,minTileX + calcWidth,maxTileX, maxTileX};
//        Integer[] yStopAr = new Integer[]{minTileY + calcHeight,  minTileY + calcHeight, minTileY + calcHeight, minTileY + calcHeight};

//Integer[] xStartAr = new Integer[]{minTileX + calcWidth -1, minTileX + calcWidth -1, minTileX + calcWidth -1, minTileX + calcWidth -1};
//Integer[] yStartAr = new Integer[]{0, 0, 0, 0};
//Integer[] xStopAr = new Integer[]{minTileX + calcWidth, minTileX + calcWidth, minTileX + calcWidth, minTileX + calcWidth};
//Integer[] yStopAr = new Integer[]{minTileY + calcHeight +1, minTileY + calcHeight +1,0,0};		
		
		// Max Thread Number
		int threadMaxNumber = numXBlocks * numYBlocks;
		ThreadPoolExecutor executor = new ThreadPoolExecutor(threadMaxNumber,
				threadMaxNumber, TIMEOUT, TimeUnit.SECONDS,
				new ArrayBlockingQueue<Runnable>(MAXIMUM_QUEUE_SIZE));

		// Counter used for the eventual xStartArray and yStartArray
		int count = 0;

		// Set used for avoiding to calculate the same arc
		ConcurrentSkipListSet<BigDecimal> set = new ConcurrentSkipListSet<BigDecimal>();

		latch = new CountDownLatch(threadMaxNumber);

		// NOT HUMAN TARGETS

		int maxX = 0;
		int maxY = 0;

		String targetID = "NotHuman";

		// Cycle on the NotHuman Targets
		boolean arrayXPresent = xStartAr != null;
		boolean arrayYPresent = yStartAr != null;

		for (int x = minTileX; x < maxTileX; x += calcWidth) {
			maxX = x + calcWidth;
			if (maxX > maxTileX) {
				maxX = maxTileX;
			}
			for (int y = minTileY; y < maxTileY; y += calcHeight) {

				maxY = y + calcHeight;
				if (maxY > maxTileY) {
					maxY = maxTileY;
				}
				// New vulnerability computation object used only inside this
				// thread
				VulnerabilityComputation vulnerability = new VulnerabilityComputation(
						inputFeature, listenerForwarder, metadataHandler,
						dataStore);

				Integer xStart = arrayXPresent ? xStartAr[count] : null;
				Integer yStart = arrayYPresent ? yStartAr[count] : null;

				Integer xStop = arrayXPresent ? xStopAr[count] : null;
				Integer yStop = arrayYPresent ? yStopAr[count] : null;
				// Thread which executes calculations
				MyRunnable run = new MyRunnable(vulnerability,
						aggregationLevel, writeMode, closePhase, images[1],
						bandPerTargetNH, set, targetID, x, maxX, y, maxY,
						skipArcs, xStart, yStart, xStop, yStop, idStart, bbox);

				executor.execute(run);
				// Counter Update
				count++;
			}
		}

		// Waiting the end of the operations of each thread
		latch.await();
		// Executor termination
		executor.shutdown();

		executor.awaitTermination(TIMEOUT, TimeUnit.SECONDS);
/*
		// HUMAN TARGETS
		// Reset of the initial set
		set.clear();
		// Counter used for the eventual xStartArray and yStartArray
		count = 0;
		// Creation of a new ThreadPoolExecutor
		executor = new ThreadPoolExecutor(threadMaxNumber, threadMaxNumber,
				TIMEOUT, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(
						MAXIMUM_QUEUE_SIZE));
		// Setting of the target to calculate to human
		targetID = "Human";
		// Creation of a new CountDownLatch
		latch = new CountDownLatch(threadMaxNumber);
		// Cycle on the Blocks
		for (int x = minTileX; x < maxTileX; x += calcWidth) {
			maxX = x + calcWidth;
			if (maxX > maxTileX) {
				maxX = maxTileX;
			}
			for (int y = minTileY; y < maxTileY; y += calcHeight) {
				maxY = y + calcHeight;
				if (maxY > maxTileY) {
					maxY = maxTileY;
				}

				Integer xStart = arrayXPresent ? xStartArray[count] : null;
				Integer yStart = arrayYPresent ? yStartArray[count] : null;

				Integer xStop = arrayXPresent ? xStopArray[count] : null;
				Integer yStop = arrayYPresent ? yStopArray[count] : null;

				VulnerabilityComputation vulnerability = new VulnerabilityComputation(
						inputFeature, listenerForwarder, metadataHandler,
						dataStore);

				MyRunnable run = new MyRunnable(vulnerability,
						aggregationLevel, writeMode, closePhase, images[0],
						bandPerTargetH, set, targetID, x, maxX, y, maxY,
						skipArcs, xStart, yStart, xStop, yStop, idStart, bbox);

				executor.execute(run);

				// Counter Update
				count++;
			}
		}

		latch.await();

		executor.shutdown();

		executor.awaitTermination(TIMEOUT, TimeUnit.SECONDS);
		*/
	}

	/**
	 * This method calculated the vulnerability on for the level 3.
	 * 
	 * Division of the input cells into N groups, and on each group the
	 * vulnerability is calculated with a Thread
	 * 
	 * 
	 * @param closePhase
	 * @param threadMaxNumber
	 * @param groups
	 * @param inputFeature
	 * @param dataStore
	 * @param metadataHandler
	 * @param images
	 * @param bandPerTargetNH
	 * @param bandPerTargetH
	 * @param writeMode
	 * @param skipArcs
	 * @param xStart
	 * @param yStart
	 * @throws Exception
	 */
	public void computeLevel3(String closePhase, int threadMaxNumber,
			RangedClassifier groups, String inputFeature,
			JDBCDataStore dataStore, MetadataIngestionHandler metadataHandler,
			RenderedImage[] images, Map<Integer, TargetInfo> bandPerTargetNH,
			Map<Integer, TargetInfo> bandPerTargetH, String writeMode,
			boolean skipArcs, Envelope2D bbox) throws Exception {

		// Executor for handling N concurrent threads
		ThreadPoolExecutor executor = new ThreadPoolExecutor(threadMaxNumber,
				threadMaxNumber, 60, TimeUnit.SECONDS,
				new ArrayBlockingQueue<Runnable>(1000000));

		// Set used for avoiding to calculate the same cell
		ConcurrentSkipListSet<BigDecimal> set = new ConcurrentSkipListSet<BigDecimal>();

		latch = new CountDownLatch(threadMaxNumber);
		// Not human target string
		String targetID = "NotHuman";
		// The only one aggregation level to calculate
		int aggregationLevel = 3;

		// Cycle on all the Cell groups
		for (int i = 0; i < threadMaxNumber; i++) {
			Double min = (Double) groups.getMin(i);
			Double max = (Double) groups.getMax(i);

			VulnerabilityComputation vulnerability = new VulnerabilityComputation(
					inputFeature, listenerForwarder, metadataHandler, dataStore);

			vulnerability.setStartOriginId(min.longValue());
			vulnerability.setEndOriginId(max.longValue());

			MyRunnable run = new MyRunnable(vulnerability, aggregationLevel,
					writeMode, closePhase, images[1], bandPerTargetNH, set,
					targetID, 0, 0, 0, 0, skipArcs, null, null, null, null , null, null);

			executor.execute(run);
		}

		// Wait until all the threads have finished their executions
		latch.await();

		executor.shutdown();

		executor.awaitTermination(TIMEOUT, TimeUnit.SECONDS);

		// HUMAN
//		// Reset of the input cell Set
//		set.clear();
//		// Change of the input target to Human
//		targetID = "Human";
//		// Latch and executor creation
//		latch = new CountDownLatch(threadMaxNumber);
//		executor = new ThreadPoolExecutor(threadMaxNumber, threadMaxNumber, 60,
//				TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(1000000));
//
//		// Cycle on all the cell groups
//		for (int i = 0; i < threadMaxNumber; i++) {
//			Double min = (Double) groups.getMin(i);
//			Double max = (Double) groups.getMax(i);
//
//			VulnerabilityComputation vulnerability = new VulnerabilityComputation(
//					inputFeature, listenerForwarder, metadataHandler, dataStore);
//
//			vulnerability.setStartOriginId(min.longValue());
//			vulnerability.setEndOriginId(max.longValue());
//
//			MyRunnable run = new MyRunnable(vulnerability, aggregationLevel,
//					writeMode, closePhase, images[0], bandPerTargetH, set,
//					targetID, 0, 0, 0, 0, skipArcs, null, null, null, null , null, bbox);
//
//			executor.execute(run);
//		}
//		latch.await();
//
//		executor.shutdown();
//
//		executor.awaitTermination(TIMEOUT, TimeUnit.SECONDS);
	}

	/**
	 * Inner class used for calculating vulnerability inside each separate
	 * thread
	 */
	class MyRunnable implements Runnable {

		private VulnerabilityComputation vln;

		private int aggregationLevel;

		private String writeMode;

		private String closePhase;

		private RenderedImage currentImage;

		private Map<Integer, TargetInfo> currentBPT;

		private ConcurrentSkipListSet<BigDecimal> keySet;

		private String targetID;

		private int minTileX;

		private int maxTileX;

		private int minTileY;

		private int maxTileY;

		private boolean skipArcs;

		private Integer xStart;

		private Integer yStart;

		private Integer xStop;

		private Integer yStop;

		private String idStart;

		private Envelope2D bbox;

		MyRunnable(VulnerabilityComputation vln, int aggregationLevel,
				String writeMode, String closePhase,
				RenderedImage currentImage,
				Map<Integer, TargetInfo> currentBPT,
				ConcurrentSkipListSet<BigDecimal> keySet, String targetID,
				int minTileX, int maxTileX, int minTileY, int maxTileY,
				boolean skipArcs, Integer xStart, Integer yStart,
				Integer xStop, Integer yStop, String idStart, Envelope2D bbox) {
			this.vln = vln;
			this.aggregationLevel = aggregationLevel;
			this.writeMode = writeMode;
			this.closePhase = closePhase;
			this.currentImage = currentImage;
			this.currentBPT = currentBPT;
			this.keySet = keySet;
			this.targetID = targetID;
			this.minTileX = minTileX;
			this.maxTileX = maxTileX;
			this.minTileY = minTileY;
			this.maxTileY = maxTileY;
			this.skipArcs = skipArcs;
			this.xStart = xStart;
			this.yStart = yStart;
			this.xStop = xStop;
			this.yStop = yStop;
			this.idStart = idStart;
			this.bbox = bbox;
		}

		@Override
		public void run() {
			try {
				vln.computeVulnerability(null, aggregationLevel, writeMode,
						closePhase, currentImage, currentBPT, keySet, targetID,
						minTileX, maxTileX, minTileY, maxTileY, skipArcs,
						xStart, yStart, xStop, yStop, idStart, bbox);
			} catch (IOException e) {
				LOGGER.error("Error Calculating Vulnerability from tile ("
						+ minTileX + "," + minTileY + ") and (" + maxTileX
						+ "," + maxTileY + ")");
			}

			latch.countDown();
		}

	}

}
