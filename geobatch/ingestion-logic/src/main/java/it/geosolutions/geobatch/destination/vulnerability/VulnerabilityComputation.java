/*
 *  Copyright (C) 2007-2012 GeoSolutions S.A.S.
 *  http://www.geo-solutions.it
 *
 *  GPLv3 + Classpath exception
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package it.geosolutions.geobatch.destination.vulnerability;

import static it.geosolutions.geobatch.destination.vulnerability.VulnerabilityComputation.PARTNER_FIELD;
import it.geosolutions.geobatch.destination.common.InputObject;
import it.geosolutions.geobatch.destination.common.OutputObject;
import it.geosolutions.geobatch.destination.common.utils.FeatureLoaderUtils;
import it.geosolutions.geobatch.destination.ingestion.MetadataIngestionHandler;
import it.geosolutions.geobatch.destination.vulnerability.TargetManager.TargetInfo;
import it.geosolutions.geobatch.destination.vulnerability.VulnerabilityOperation.OperationType;
import it.geosolutions.geobatch.flow.event.ProgressListenerForwarder;
import it.geosolutions.jaiext.bandmerge.BandMergeCRIF;
import it.geosolutions.jaiext.bandmerge.BandMergeDescriptor;
import it.geosolutions.jaiext.nullop.NullCRIF;
import it.geosolutions.jaiext.nullop.NullDescriptor;

import java.awt.RenderingHints;
import java.awt.image.DataBuffer;
import java.awt.image.RenderedImage;
import java.io.File;
import java.io.IOException;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.concurrent.ConcurrentSkipListSet;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.media.jai.JAI;
import javax.media.jai.PlanarImage;
import javax.media.jai.RenderedOp;

import org.geotools.data.DefaultTransaction;
import org.geotools.data.FeatureSource;
import org.geotools.data.Query;
import org.geotools.data.Transaction;
import org.geotools.feature.FeatureCollection;
import org.geotools.feature.FeatureIterator;
import org.geotools.filter.SortByImpl;
import org.geotools.filter.function.Classifier;
import org.geotools.geometry.DirectPosition2D;
import org.geotools.geometry.Envelope2D;
import org.geotools.image.jai.Registry;
import org.geotools.jdbc.JDBCDataStore;
import org.opengis.feature.simple.SimpleFeature;
import org.opengis.feature.simple.SimpleFeatureType;
import org.opengis.filter.Filter;
import org.opengis.filter.expression.Function;
import org.opengis.filter.sort.SortOrder;
import org.opengis.referencing.crs.CoordinateReferenceSystem;
import org.opengis.referencing.operation.MathTransform;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.vividsolutions.jts.geom.Geometry;

/**
 * This class is the entry point for the vulnerability process (method computeVulnerability) and it implements the computation's main loop
 * 
 * @author DamianoG
 * @author Daniele Romagnoli, GeoSolutions SAS
 */
public class VulnerabilityComputation extends InputObject {

    public static final String JAI_EXT_PRODUCT = "it.geosolutions.jaiext.roiaware";

    private static final int MAX_TEMP_CALC = 20;

    private static final int BBOX_COORD_NUM = 4;

    private final static Logger LOGGER = LoggerFactory.getLogger(VulnerabilityComputation.class);

    private static Pattern TYPE_NAME_PARTS = Pattern
            .compile("^([A-Z]{2})_([A-Z]{1})_([A-Za-z]+)_([0-9]{8})(_ORIG)?$");

    public static String GEO_TYPE_NAME = "siig_geo_ln_arco_X";

    public static String VULNERABILITY_TYPE_NAME = "siig_t_vulnerabilita_X";

    private static String DISTANCE_TYPE_NAME = "siig_d_distanza";

    private static String ID_GEO_ARCO = "id_geo_arco";

    public static String PARTNER_FIELD = "fk_partner";

    public static String GEOID = "id_geo_arco";

    public final static String RASTER_PATH_PROP = "SIIG_RASTERS_PATH";

    private Long startOriginId;

    private Long endOriginId;

    private Long totPages;

    private Long pageNumber;

    private int pixelArea;

    private Map vulnerabilityCfg;

    String codicePartner;

    int partner;

    static {
        try {
            Registry.registerRIF(JAI.getDefaultInstance(), new BandMergeDescriptor(),
                    new BandMergeCRIF(), JAI_EXT_PRODUCT);

            Registry.registerRIF(JAI.getDefaultInstance(), new NullDescriptor(), new NullCRIF(),
                    JAI_EXT_PRODUCT);

        } catch (Throwable e) {
            // swallow exception in case the op has already been registered.
        }
    }

    /**
     * @param startOriginId the startOriginId to set
     */
    public void setStartOriginId(Long startOriginId) {
        this.startOriginId = startOriginId;
    }

    /**
     * @param endOriginId the endOriginId to set
     */
    public void setEndOriginId(Long endOriginId) {
        this.endOriginId = endOriginId;
    }

    /**
     * @param pixelArea the pixelArea to set
     */
    public void setPixelArea(int pixelArea) {
        this.pixelArea = pixelArea;
    }

    /**
     * @param totPages the totPages to set
     */
    public void setTotPages(Long totPages) {
        this.totPages = totPages;
    }

    /**
     * @param pageNumber the pageNumber to set
     */
    public void setPageNumber(Long pageNumber) {
        this.pageNumber = pageNumber;
    }

    /**
     * @param inputTypeName
     * @param listenerForwarder
     */
    public VulnerabilityComputation(String inputTypeName,
            ProgressListenerForwarder listenerForwarder, MetadataIngestionHandler metadataHandler,
            JDBCDataStore dataStore) {
        super(inputTypeName, listenerForwarder, metadataHandler, dataStore);
        // default area
        pixelArea = 100;
    }

    @Override
    protected String getInputTypeName(String inputTypeName) {
        return inputTypeName.replace("_ORIG", "");
    }

    @Override
    protected boolean parseTypeName(String typeName) {
        Matcher m = TYPE_NAME_PARTS.matcher(typeName);
        if (m.matches()) {
            // partner alphanumerical abbreviation (from siig_t_partner)
            codicePartner = m.group(1);
            // partner numerical id (from siig_t_partner)
            partner = Integer.parseInt(partners.get(codicePartner).toString());

            return true;
        }
        return false;
    }

    private String getTypeName(String typeName, int aggregationLevel) {
        return typeName.replace("X", aggregationLevel + "");
    }

    /**
     * Compute the vulnerability for each arc. The Algorithm is:
     * 
     * ForEach(target) buffers = computeBuffers(allDistance, arc); ForEach(distance) if(!isAccepted(distance,target)) saveOnDB(0,arc,target,distance)
     * continue; sum = computeSum(buffer, target); ForEach(arc) saveOnDB(sum,arc,target,distance);
     * 
     * 
     * @param datastoreParams
     * @param crs
     * @param aggregationLevel
     * @throws IOException
     */
    public void computeVulnerability(CoordinateReferenceSystem crs, int aggregationLevel,
            String writeMode, String closePhase, RenderedImage currentImage,
            Map<Integer, TargetInfo> currentBPT, ConcurrentSkipListSet<BigDecimal> keySet,
            String targetID, int minTileX, int maxTileX, int minTileY, int maxTileY,
            String cellStart, String cellStop, boolean skipArcs, Integer xStart, Integer yStart,
            String idStart) throws IOException {

        reset();
        if (isValid()) {

            crs = checkCrs(crs);

            String outFeatureName = getTypeName(VULNERABILITY_TYPE_NAME, aggregationLevel);

            int process = -1;
            int trace = -1;
            int errors = 0;
            long otherErrors = 0;

            // existing process
            MetadataIngestionHandler.Process importData = getProcessData();
            process = importData.getId();
            trace = (importData.getMaxTrace());
            errors = (importData.getMaxError());
            int startErrors = errors;

            if (process == -1) {
                LOGGER.error("Cannot find process for input file");
                throw new IOException("Cannot find process for input file");
            }

            // Sort Order
            SortByImpl order = new SortByImpl(filterFactory.property(GEOID), SortOrder.ASCENDING);
            
            //
            // Load All needed resources: properties files, Rendered Images, GeotifReaders
            //
            vulnerabilityCfg = (Map) readResourceFromXML("/vulnerability.xml");
            String basePath = System.getProperty(RASTER_PATH_PROP, "");
            if (!basePath.equals("")) {
                basePath = basePath + File.separator + codicePartner;
            }
            VulnerabilityStatsEngine vse = new VulnerabilityStatsEngine(basePath, vulnerabilityCfg,
                    dataStore, DISTANCE_TYPE_NAME, pixelArea);

            ResultStatsMap statsMap = new ResultStatsMap(vulnerabilityCfg);

            // Setup the OutputObject (in thet case the vulnerability table) remove old values for the partner and detect the max id
            Transaction transaction = new DefaultTransaction();
            OutputObject vulnerabilityObj = new OutputObject(dataStore, transaction,
                    outFeatureName, GEOID);

            VulnerabilityOperation concreteOperation;
            // Human targets
            if (targetID.equalsIgnoreCase("Human")) {

                //
                // Load the concrete operation (Update)
                //
                VulnerabilityOperation updateOperation = VulnerabilityOperation
                        .instantiateWriter(OperationType.UPDATE);
                LOGGER.info("Using writer " + VulnerabilityOperation.class);
                updateOperation.initFeature(vulnerabilityObj, partner);
                // Setup filtering
                updateOperation.setStartOriginId(startOriginId);
                updateOperation.setEndOriginId(endOriginId);
                updateOperation.setPageNumber(pageNumber);
                updateOperation.setTotPages(totPages);

                concreteOperation = updateOperation;
                // Not Human targets
            } else {

                //
                // Load the concrete operation (Insert or PurgeInsert)
                //
                VulnerabilityOperation insertOperation = VulnerabilityOperation
                        .instantiateWriterFromString(writeMode);
                LOGGER.info("Using writer " + VulnerabilityOperation.class);
                insertOperation.initFeature(vulnerabilityObj, partner);
                // Setup filtering
                insertOperation.setStartOriginId(startOriginId);
                insertOperation.setEndOriginId(endOriginId);
                insertOperation.setPageNumber(pageNumber);
                insertOperation.setTotPages(totPages);

                concreteOperation = insertOperation;
            }

            //
            // Start the vulnerability Computation
            //
            long start = System.nanoTime();
            try {
                SimpleFeature inputFeature = null;
                int loopCounter = 0;
                List<Double> allDistances = vse.getDistances();
                int reportingLoopStep = allDistances.size() > 10 ? 50 : 100;

                // setup geo input / output object
                String geoName = getTypeName(GEO_TYPE_NAME, aggregationLevel);
                if (aggregationLevel == 3) {
                    geoName = geoName.replace("ln", "pl");
                }
                createInputReader(dataStore, null, geoName);

                Filter partnerFilter = filterFactory.equals(filterFactory.property(PARTNER_FIELD),
                        filterFactory.literal(partner));
                setInputFilter(partnerFilter);

                int total = getImportCount();

                // setInputFilter(concreteOperation.buildOriginFilter(partner, total));

                // calculates total objects to import
                LOGGER.info("import count: " + total);
                // Map<String, TargetInfo> targetInfo = vse.getTargetInfo();

                LOGGER.info("Start computation: ThreadName: " + Thread.currentThread().getName()
                        + " - startOriginId: " + startOriginId + " - endOriginId: " + endOriginId);
                String idArco = null;
                Double currentDistance = null;

                try {
                    // Creation of a List of features
                    List<SimpleFeature> arcList = new ArrayList<SimpleFeature>();

                    if (aggregationLevel != 3) {
                        // Preliminar Checks
                        if (minTileX > maxTileX) {
                            int temp = minTileX;
                            minTileX = maxTileX;
                            maxTileX = temp;
                        }
                        if (minTileY > maxTileY) {
                            int temp = minTileY;
                            minTileY = maxTileY;
                            maxTileY = temp;
                        }

                        // Creation of a list of the arc Ids
                        List<String> arcIds = new ArrayList<String>();
                        // Load the Transformation associated with the selected target and calculate the inverse
                        TargetInfo firstInfo = currentBPT.get(0);
                        MathTransform w2g = firstInfo.getWorld2Grid();
                        MathTransform g2w = w2g.inverse();
                        // Load the target dimensions for modifying the spatial filter
                        int minX = 0;
                        int minY = 0;

                        int tileWidth = currentImage.getTileWidth();
                        int tileHeight = currentImage.getTileHeight();

                        int tileGridX = currentImage.getTileGridXOffset();

                        int tileGridY = currentImage.getTileGridYOffset();

                        double[] srcPts = new double[BBOX_COORD_NUM];

                        double[] dstPts = new double[BBOX_COORD_NUM];

                        DirectPosition2D minXY = new DirectPosition2D(0, 0);

                        DirectPosition2D maxXY = new DirectPosition2D(0, 0);
                        // Setting of the bounding box
                        Envelope2D env = new Envelope2D(minXY, maxXY);

                        double height = 0;
                        double width = 0;

                        // Iteration on image tiles
                        for (int x = minTileX; x < maxTileX; x++) {

                            // For each tile, the points are transformed in the world crs

                            minX = PlanarImage.tileXToX(x, tileGridX, tileWidth);

                            if (xStart != null && xStart > minX) {
                                continue;
                            }

                            for (int y = minTileY; y < maxTileY; y++) {

                                minY = PlanarImage.tileYToY(y, tileGridY, tileHeight);

                                if (yStart != null && yStart > minY) {
                                    continue;
                                }

                                // Source Coordinates
                                srcPts[0] = minX;
                                srcPts[1] = minY;
                                srcPts[2] = minX + tileWidth;
                                srcPts[3] = minY + tileHeight;
                                // Coordinates transformation
                                g2w.transform(srcPts, 0, dstPts, 0, 2);
                                // Creation of the BoundingBox associated with the selected tile
                                height = Math.abs(dstPts[3] - dstPts[1]);
                                width = Math.abs(dstPts[2] - dstPts[0]);

                                env.x = dstPts[0];
                                env.y = dstPts[1];
                                env.height = height;
                                env.width = width;

                                // Creation of a spatial filter for taking only the features associated
                                // to the selected bounding box

                                if ((xStart != null && x == xStart)
                                        && (yStart != null && y == yStart) && idStart != null) {
                                    setInputFilter(concreteOperation.buildOriginFilterExtended(
                                            partner, total, env, idStart));
                                } else {
                                    setInputFilter(concreteOperation.buildOriginFilterExtended(
                                            partner, total, env, null));
                                }

                                // The input filter is created, then we check
                                // the size of the input features returned
                                int featureSize = inputSize();

                                inputFeature = readInputSorted();
                                // Check if the ARC has been already processed
                                if (inputFeature != null && skipArcs
                                        && targetID.equalsIgnoreCase("NotHuman")) {
                                    // Selection of the id associated to the feature.
                                    BigDecimal arcId = ((BigDecimal) inputFeature
                                            .getAttribute(ID_GEO_ARCO));

                                    if (!FeatureLoaderUtils
                                            .createFeatureSource(dataStore, transaction,
                                                    outFeatureName)
                                            .getFeatures(
                                                    filterFactory.equals(
                                                            filterFactory.property(GEOID),
                                                            filterFactory.literal(arcId)))
                                            .isEmpty()) {
                                        featureSize = 0;
                                    }
                                }
                                // Temporary List used for buffer computation
                                List<SimpleFeature> temporaryList = new ArrayList<SimpleFeature>(1);
                                // BufferList
                                List<MultipleBufferMap> bufferList = new ArrayList<MultipleBufferMap>();
                                // Creation of a temporary ResultMapList
                                List<ResultStatsMap> statList = new ArrayList<ResultStatsMap>();

                                int featureCounter = 0;
                                while (featureCounter < featureSize) {

                                    int temporaryCounter = 0;

                                    // Iteration on the image tile for searching all the geometries
                                    while (temporaryCounter <= MAX_TEMP_CALC
                                            && inputFeature != null) {
                                        // Selection of the id associated to the feature.
                                        BigDecimal arcId = ((BigDecimal) inputFeature
                                                .getAttribute(ID_GEO_ARCO));

                                        // Check if the feature has been already taken
                                        boolean notContained = keySet.add(arcId);
                                        if (notContained) {
                                            arcList.add(inputFeature);
                                            // Selection of the arc id
                                            idArco = arcId.toString();
                                            // Update of the arc id list
                                            arcIds.add(idArco);

                                            // Addition on the temporary list
                                            temporaryList.add(inputFeature);
                                            MultipleBufferMap mbm = vse.computeBuffersOnArcs(
                                                    temporaryList, allDistances);
                                            temporaryList.clear();
                                            // Add the buffer for the selected arc
                                            bufferList.add(mbm);
                                            // Update of the Loop Counter
                                            loopCounter++;
                                            // Update of the logger in debug
                                            if (LOGGER.isDebugEnabled() && inputFeature != null) {
                                                LOGGER.debug("Raster=" + targetID + ", TILE=(" + x
                                                        + "," + y + ") Computing arc " + idArco);
                                            }
                                        }
                                        temporaryCounter++;
                                        inputFeature = readInputSorted();
                                    }

                                    // BUFFER CALCULATION

                                    // If almost an arc is present
                                    int arcSize = arcList.size();

                                    String id = null;

                                    if (arcSize > 0) {
                                        try {

                                            // Iteration on all the buffers
                                            for (Double processedDistance : allDistances) {

                                                // Check if the distance is related to the selected target
                                                // Empty map used for containing only the accepted targets
                                                Map<Integer, TargetInfo> acceptedBands = new TreeMap<Integer, TargetManager.TargetInfo>();
                                                // Set of all the bands
                                                Set<Integer> keys = currentBPT.keySet();
                                                // Cycle on all the targets
                                                for (int band : keys) {
                                                    // Selection of the TargetInfo
                                                    TargetInfo infoPerBand = currentBPT.get(band);
                                                    // TargetManager associated
                                                    TargetManager mng = infoPerBand.getManager();
                                                    // If the distance is related to the target, then it is added to the map of the accepted band
                                                    if (mng.isDistanceRelatedToTarget(processedDistance)) {
                                                        acceptedBands.put(band, infoPerBand);
                                                    }
                                                }
                                                // Statistical computation

                                                // The statistics are calculated only if almost one of the targets accepts the current distance
                                                if (!acceptedBands.isEmpty()) {
                                                    // Number of ResultStatsMap already present
                                                    int statListSize = statList.size();
                                                    // Number of buffer to calculate
                                                    int buffListSize = bufferList.size();
                                                    // If the ResultStatsMap are not enough, they are calculated until they reach the desired
                                                    // number
                                                    if (statListSize < buffListSize) {
                                                        int difference = buffListSize
                                                                - statListSize;

                                                        for (int i = 0; i < difference; i++) {
                                                            statList.add(new ResultStatsMap(
                                                                    vulnerabilityCfg));
                                                        }
                                                    }
                                                    List<Geometry> geometryList = new ArrayList<Geometry>();
                                                    // Addition of the buffer associated with the selected distance and arc
                                                    for (MultipleBufferMap mbm : bufferList) {

                                                        // Use the cell for crop the raster if the aggregation level == 3, use the buffer
                                                        // otherwise
                                                        Geometry bufferArea = (Geometry) mbm
                                                                .getBuffersForDistance(
                                                                        processedDistance).get(0);

                                                        geometryList.add(bufferArea);
                                                    }
                                                    // Calculation
                                                    try {
                                                        vse.computeStats(geometryList,
                                                                currentImage, statList, false,
                                                                acceptedBands);

                                                    } catch (Exception e) {
                                                        errors++;
                                                        metadataHandler
                                                                .logError(
                                                                        trace,
                                                                        errors,
                                                                        "Raster="
                                                                                + targetID
                                                                                + ", TILE=("
                                                                                + x
                                                                                + ","
                                                                                + y
                                                                                + ") Error writing objects on "
                                                                                + geoName,
                                                                        getError(e), 0);
                                                        LOGGER.error(
                                                                "Raster="
                                                                        + targetID
                                                                        + ", TILE=("
                                                                        + x
                                                                        + ","
                                                                        + y
                                                                        + ") Error calculating statistics on "
                                                                        + geoName, e);
                                                    }

                                                    // When a certain number of geometries are calculated, a report is printed
                                                    if (loopCounter % reportingLoopStep == 0) {
                                                        LOGGER.info("Raster=" + targetID
                                                                + ", TILE=(" + x + "," + y
                                                                + ") computed arcs FROM -"
                                                                + (loopCounter - reportingLoopStep)
                                                                + "- TO -" + loopCounter + "-");
                                                    }
                                                    // The Buffer List is cleared
                                                    geometryList.clear();
                                                }
                                                // Iteration on all the geometries list
                                                for (int i = 0; i < arcSize; i++) {

                                                    // Selection of the arc
                                                    SimpleFeature arc = arcList.get(i);
                                                    // Selection of the arcId
                                                    String arcId = arcIds.get(i);

                                                    // Creation of the identifier associated with the distance
                                                    id = buildFid(arcId, processedDistance);
                                                    // ResultStatsMap associated with the arc
                                                    ResultStatsMap resMap;
                                                    if (!acceptedBands.isEmpty()) {
                                                        resMap = statList.get(i);
                                                    } else {
                                                        resMap = new ResultStatsMap(
                                                                vulnerabilityCfg);
                                                    }

                                                    try {
                                                        // Writing of the result for the selected distance and Id
                                                        concreteOperation.writeOutputObjects(trace,
                                                                vulnerabilityObj, total,
                                                                outFeatureName, arc, id,
                                                                resMap.getStatsMap(), partner);
                                                        // DEBUG: indication of which arc is calculated
                                                        if (LOGGER.isDebugEnabled()) {
                                                            LOGGER.debug("Raster=" + targetID
                                                                    + ", TILE=(" + x + "," + y
                                                                    + ") Computed arc "
                                                                    + arc.getAttribute(GEOID)
                                                                    + "for distance="
                                                                    + processedDistance);
                                                        }
                                                    } catch (Exception e) {
                                                        errors++;
                                                        metadataHandler
                                                                .logError(
                                                                        trace,
                                                                        errors,
                                                                        "Raster="
                                                                                + targetID
                                                                                + ", TILE=("
                                                                                + x
                                                                                + ","
                                                                                + y
                                                                                + ") Error writing objects on "
                                                                                + geoName,
                                                                        getError(e), 0);
                                                        LOGGER.error("Raster=" + targetID
                                                                + ", TILE=(" + x + "," + y
                                                                + ") Error writing objects on "
                                                                + geoName, e);
                                                    }

                                                    // Clearing of the associated ResultStatsMap
                                                    if (!resMap.isEmpty()) {
                                                        resMap.clear();
                                                    }
                                                }
                                            }

                                        } catch (Exception e) {
                                            errors++;
                                            LOGGER.error("Raster=" + targetID + ", TILE=(" + x
                                                    + "," + y + ") Error writing objects on "
                                                    + geoName, e);
                                        }
                                    }

                                    // At the end of the operation on this list
                                    // all the geometries are cleared for the next
                                    // cell.
                                    arcList.clear();
                                    arcIds.clear();
                                    bufferList.clear();
                                    featureCounter += temporaryCounter;
                                }
                                // INPUT READER CLOSURE
                                try {
                                    // closeInputReader();
                                } catch (Exception e) {
                                    errors++;
                                    metadataHandler.logError(trace, errors, "Raster=" + targetID
                                            + ", TILE=(" + x + "," + y
                                            + ") Error closing inputReader", getError(e), 0);
                                    LOGGER.error("Raster=" + targetID + ", TILE=(" + x + "," + y
                                            + ") Error closing inputReader", e);
                                }
                            }
                        }

                        // Reset of the Loop Counter
                        loopCounter = 0;
                        // AGGREGATION LEVEL 3
                    } else {
                        // Setting of the input filter
                        BigDecimal idCellStart = new BigDecimal(cellStart);
                        BigDecimal idCellStop = new BigDecimal(cellStop);
                        
                        concreteOperation.setStartOriginId(idCellStart.longValue());
                        concreteOperation.setEndOriginId(idCellStop.longValue());
                        
                        setInputFilter(concreteOperation.buildOriginFilter(partner, total));

                        while ((inputFeature = readInputSorted()) != null) {

                            // Selection of the id associated to the feature.
                            BigDecimal arcId = ((BigDecimal) inputFeature.getAttribute(ID_GEO_ARCO));
                            
                            // Check if the feature has been already taken
                            boolean notContained = keySet.add(arcId);                            
                            if(!notContained){
                                loopCounter++;
                                continue;
                            }
                            
                            // For level 3, get all the arcs that intersect with the current grid cell
                            FeatureIterator<SimpleFeature> iterator = null;
                            try {
                                // Cell element
                                Geometry cell = (Geometry) inputFeature.getDefaultGeometry();
                                String linearGeoName = geoName.replace("pl", "ln");
                                FeatureSource<SimpleFeatureType, SimpleFeature> reader = createInputReader(
                                        dataStore, null, linearGeoName);
                                // Iterator for selecting all the geometries intersecting the cell

                                BigDecimal idCell = (BigDecimal) inputFeature
                                        .getAttribute(ID_GEO_ARCO);

                                Filter featureFilter = filterFactory.and(filterFactory.intersects(
                                        filterFactory.property(getInputGeometryName(dataStore,
                                                linearGeoName)), filterFactory.literal(cell)),
                                        partnerFilter);

                                if (idCell == idCellStart && idStart != null) {
                                    featureFilter = filterFactory.and(featureFilter, filterFactory
                                            .greater(filterFactory.property(GEOID),
                                                    filterFactory.literal(idStart)));
                                }
                                iterator = reader.getFeatures(featureFilter).sort(order).features();

                                while (iterator.hasNext()) {
                                    SimpleFeature sf = (SimpleFeature) iterator.next();
                                    // addition of the simple feature to the list
                                    arcList.add(sf);
                                }
                            } catch (Exception e) {
                                LOGGER.error("Raster=" + targetID + ", Error reading " + geoName, e);
                                errors++;
                                metadataHandler.logError(trace, errors, "Raster=" + targetID
                                        + ", Error reading " + geoName, getError(e), 0);
                            } finally {
                                if (iterator != null) {
                                    iterator.close();
                                }
                            }
                            // BUFFER CALCULATION
                            // If almost an arc is present
                            if (arcList.size() > 0) {
                                // Selection of the arc id
                                idArco = ((BigDecimal) inputFeature.getAttribute(ID_GEO_ARCO))
                                        .toString();

                                // computeBuffersOnArcs
                                MultipleBufferMap mbm = vse.computeBuffersOnArcs(arcList,
                                        allDistances);

                                String id = null;

                                try {

                                    // Iteration on all the buffers
                                    for (Double processedDistance : allDistances) {
                                        // Check if the distance is related to the selected target
                                        // Empty map used for containing only the accepted targets
                                        Map<Integer, TargetInfo> acceptedBands = new TreeMap<Integer, TargetManager.TargetInfo>();
                                        // Set of all the bands
                                        Set<Integer> keys = currentBPT.keySet();
                                        // Cycle on all the targets
                                        for (int band : keys) {
                                            // Selection of the TargetInfo
                                            TargetInfo infoPerBand = currentBPT.get(band);
                                            // TargetManager associated
                                            TargetManager mng = infoPerBand.getManager();
                                            // If the distance is related to the target, then it is added to the map of the accepted band
                                            if (mng.isDistanceRelatedToTarget(processedDistance)) {
                                                acceptedBands.put(band, infoPerBand);
                                            }
                                        }
                                        // Creation of the identifier associated with the distance
                                        id = buildFid(idArco, processedDistance);

                                        // Statistics computation

                                        // The statistics are calculated only if almost one of the targets accepts the current distance
                                        if (!acceptedBands.isEmpty()) {
                                            vse.computeStats(
                                                    mbm.getBuffersForDistance(processedDistance),
                                                    currentImage, statsMap, false, acceptedBands);
                                        }
                                        try {
                                            // Writing of the result for the selected distance and Id
                                            concreteOperation.writeOutputObjects(trace,
                                                    vulnerabilityObj, total, outFeatureName,
                                                    inputFeature, id, statsMap.getStatsMap(),
                                                    partner);
                                        } catch (Exception e) {
                                            errors++;
                                            metadataHandler.logError(trace, errors, "Raster="
                                                    + targetID + ", Error writing objects on "
                                                    + geoName, getError(e), 0);
                                            LOGGER.error("Raster=" + targetID
                                                    + ", Error writing objects on " + geoName, e);
                                        }

                                        if (!statsMap.isEmpty()) {
                                            statsMap.clear();
                                        }
                                    }

                                } catch (Exception e) {
                                    errors++;
                                    LOGGER.error("Raster=" + targetID
                                            + ", Error writing objects on " + geoName, e);
                                }
                                // At the end of the operation on this list
                                // all the geometries are cleared for the next
                                // cell
                                arcList.clear();
                            }
                            // Update of the LoopCounter
                            loopCounter++;

                            // When a certain number of geometries are calculated, a report is printed
                            if (loopCounter % reportingLoopStep == 0) {
                                LOGGER.info("Raster=" + targetID + ", computed arcs FROM -"
                                        + (loopCounter - reportingLoopStep) + "- TO -"
                                        + loopCounter + "-");
                            }
                            // DEBUG: indication of which arc is calculated
                            if (LOGGER.isDebugEnabled() && inputFeature != null) {
                                LOGGER.debug("Raster=" + targetID + ", Computed cell "
                                        + inputFeature.getAttribute(GEOID));
                            }
                        }

                        // Wait until all the computations are finished

                        // Reset of the Loop Counter
                        loopCounter = 0;
                    }
                } catch (Exception e) {
                    errors++;
                    metadataHandler.logError(trace, errors, "Raster=" + targetID
                            + ", Error occurred on raster: " + targetID + " for distance "
                            + currentDistance + " on arc:" + idArco, getError(e), 0);
                    LOGGER.error(
                            "Raster=" + targetID + ", Error occurred on raster: " + targetID
                                    + " for distance " + currentDistance + " on arc:" + idArco
                                    + "\n" + e.getMessage(), e);
                } finally {
                    try {

                        // closeInputReader();
                    } catch (Exception e) {
                        errors++;
                        metadataHandler.logError(trace, errors, "Raster=" + targetID
                                + ", Error closing inputReader", getError(e), 0);
                        LOGGER.error("Raster=" + targetID + ", Error closing inputReader", e);
                    }
                }

                // Report about the end of the input
                importFinishedModified(total, loopCounter, errors - startErrors,
                        "Data imported in " + outFeatureName);
            } finally {
                closeInputReader();
                LOGGER.info("Write errors: " + errors + " - other errors: " + otherErrors);

                if (process != -1 && closePhase != null) {
                    // close current process phase
                    metadataHandler.closeProcessPhase(process, closePhase);
                }
                transaction.close();
            }

            long end = System.nanoTime() - start;

            double time = end * (10E-9) / 60;

            System.out
                    .println("New version of the vulnerability computation for the aggregation level "
                            + aggregationLevel + " takes " + time + " minutes");

        }
    }

    private static String buildFid(String idArco, Double el) {
        return idArco + "." + el.intValue();
    }

    /**
     * Method used for merging the input Rasters into a 2 images, one for human targets and the other for not human targets
     * 
     * @param humanTargets
     * @param notHumanTargets
     * @param bandPerTargetH
     * @param bandPerTargetNH
     * @throws IOException
     */
    public RenderedImage[] rasterCalculation(Map<Integer, TargetInfo> bandPerTargetH,
            Map<Integer, TargetInfo> bandPerTargetNH) throws IOException {
        RenderedImage humanTargets = null;
        RenderedImage notHumanTargets = null;
        String basePath = System.getProperty(RASTER_PATH_PROP, "");
        if (!basePath.equals("")) {
            basePath = basePath + File.separator + codicePartner;
        }

        Map vulnerabilityConf = (Map) readResourceFromXML("/vulnerability.xml");

        VulnerabilityStatsEngine vsengine = new VulnerabilityStatsEngine(basePath,
                vulnerabilityConf, dataStore, DISTANCE_TYPE_NAME, pixelArea);

        Map<String, TargetInfo> targetInfo = vsengine.getTargetInfo();

        /*
         * Creation of 2 images: one for the HUMAN TARGETS and the other for NOT HUMAN TARGETS
         */
        // List of Human Targets
        List<RenderedImage> humanList = new ArrayList<RenderedImage>();

        // List of Not Human Targets
        List<RenderedImage> notHumanList = new ArrayList<RenderedImage>();

        // Counters indicating which band is associated to the TargetInfo and Image
        int humanBandCounter = 0;
        int notHumanBandCounter = 0;

        // Iterator on all the targets
        Iterator<String> rasterIter = targetInfo.keySet().iterator();

        // HP 1 ALL THE TARGETS HAVE THE SAME NODATA
        // HP 2 ALL THE TARGETS HAVE THE SAME WORLD2GRID TRANSFORMATION
        // HP 3 ALL THE TARGETS HAVE THE SAME DIMENSIONS

        while (rasterIter.hasNext()) {
            // save the ID of this target
            String targetID = rasterIter.next();

            // Load the target manager, init its status and check if the actual distance is a valid distance for it
            TargetInfo info = targetInfo.get(targetID);

            TargetManager manager = info.getManager();

            // Image associated to the current target
            RenderedImage newImage = info.getRaster();

            int imgDataType = newImage.getSampleModel().getDataType();

            if (newImage != null) {
                // If the target is human
                if (manager.isHumanTarget()) {

                    if (imgDataType != DataBuffer.TYPE_FLOAT) {
                        System.out.println("Wrong data type");
                    }

                    // Addition of the TargetInfo of this target
                    bandPerTargetH.put(humanBandCounter, info);
                    // Update of the bandCounter
                    humanBandCounter++;
                    // Addition of the image to the associated list
                    humanList.add(newImage);
                    // If the target is not human
                } else {

                    if (imgDataType != DataBuffer.TYPE_BYTE) {
                        System.out.println("Wrong data type");
                    }

                    // Addition of the TargetInfo of this target
                    bandPerTargetNH.put(notHumanBandCounter, info);
                    // Update of the bandCounter
                    notHumanBandCounter++;
                    // Addition of the image to the associated list
                    notHumanList.add(newImage);
                }
            }
        }

        // BandMerge of the images
        RenderedImage[] imagesHuman = new RenderedImage[humanList.size()];
        RenderedImage[] imagesNotHuman = new RenderedImage[notHumanList.size()];

        humanTargets = BandMergeDescriptor.create(null, 0, VulnerabilityUtils.NO_TILE_CACHE,
                humanList.toArray(imagesHuman));

        notHumanTargets = BandMergeDescriptor.create(null, 0, VulnerabilityUtils.NO_TILE_CACHE,
                notHumanList.toArray(imagesNotHuman));

        // cache the final image
        humanTargets = NullDescriptor.create(humanTargets, new RenderingHints(JAI.KEY_TILE_CACHE,
                JAI.getDefaultInstance().getTileCache()));
        // ((RenderedOp)humanTargets).getTiles();
        notHumanTargets = NullDescriptor.create(notHumanTargets, new RenderingHints(
                JAI.KEY_TILE_CACHE, JAI.getDefaultInstance().getTileCache()));

        return new RenderedImage[] { humanTargets, notHumanTargets };

    }

    public FeatureCollection<SimpleFeatureType,SimpleFeature> geometryIDList() throws IOException {

        int aggregationLevel = 3;
        // setup geo input / output object
        String geoName = getTypeName(GEO_TYPE_NAME, aggregationLevel);
        geoName = geoName.replace("ln", "pl");
        createInputReader(dataStore, null, geoName);

        // Setting of the input filter
        // Simple filter on the partner
        
        Filter filter = filterFactory.equals(filterFactory.property(PARTNER_FIELD),
                filterFactory.literal(partner));
        setInputFilter(filter);
        
        FeatureCollection<SimpleFeatureType,SimpleFeature> cells = readCollectionSorted();                       

        
        return cells;
    }
}
